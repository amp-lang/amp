fn print(string: &String) {
    @print_size(string.pointer, string.length)
}

fn println(string: &String) {
    print(string)
    print("\n")
}

fn error(string: String) {
    @error_size(string, length(string))
}

fn errorln(string: String) {
    error(string)
    error("\n")
}

fn read(): String {
    let string = @allocate(128)
    @read_size(string, 128)
    return String(string, 128)
}

fn read_file(file: String): String {
    let file_null_terminated = file + "\0"
    let size = @get_file_size(file_null_terminated.pointer)
    let string = @allocate(size)
    @read_file_size(file_null_terminated.pointer, string, size)
    return String(string, size)
}

fn execute_command(file: String, arguments: Array<String>, wait: boolean) {
	let null_terminated_file = file + "\0"
	let arguments_new = Array<any>(arguments.length + 1)
	let i = 0
	while i < arguments.length {
		let thing = @cast_&String(arguments[i]) + "\0"
		arguments_new[i] = @cast_any(thing.pointer_consume())
		i = i + 1
	}

	@execute(null_terminated_file.pointer, arguments_new.pointer, wait)

	let i = 0
	while i < arguments_new.length - 1 {
		let argument = arguments_new[i]
		@free(argument, length(argument) + 1)
		i = i + 1
	}
}

fn length(string: &any): integer {
    let location = string
    let i = 0

    while true {
        if (@get_1(location) == 0) {
            return i
        }
        location = location + 1
        i = i + 1
    }

    return 999
}

fn _+(string1: &String, string2: &String): String {
    let string1_length = string1.length
    let string2_length = string2.length
    let new_memory = @allocate(string1_length + string2_length)
    @copy(string1.pointer, new_memory, string1_length)
    @copy(string2.pointer, new_memory + string1_length, string2_length)
    return String(new_memory, string1_length + string2_length)
}

fn integer_to_string(integer: integer): String {
    let string = ""
    if integer == 0 {
        string = "0"
    }
    
    while integer > 0 {
        let modulo = integer % 10
        integer = integer / 10
        let prepended_string = String(store(modulo + 48), 1)
        string = prepended_string +string
    }

    return string
}

fn boolean_to_string(boolean: boolean): String {
    if boolean {
        return "true"
    }
    return "false"
}

fn store(value: integer): any {
    let new_memory = @allocate(1)
    @set_1(new_memory, value)
    return new_memory
}

fn not_equal(value1: &any, value2: &any): boolean {
    return @not(@equal(value1, value2))  
}

struct Array<A> {
    pointer: any
    length: integer

	fn <A>(size: integer): Array<A> {
	    return Array<A>(@allocate(size * 8), size)
	}

	fn free_custom<A>(array: &Array<A>) {
		if A.memory_size() > 0 {
			let i = 0
			while i < array.length {
				if @not(array[i] == 0) {
                    let _ = @cast_A(@cast_any(@cast_&any(array[i])))
				}
				i = i + 1
			}
		}
		@free(array.pointer, array.length * 8)
	}
}

fn _[]=<A>(array: &Array<A>, index: integer, value: A) {
    @set_8(array.pointer + (index * 8), @cast_integer(value))
}

fn _[]<A>(array: &Array<A>, index: integer): &A {
    return @cast_&A(@get_8(array.pointer + (index * 8)))
}

struct Function {
    pointer: any

	fn call(function: &Function, parameters: Array<any>): any {
	    return @call_function(function.pointer, parameters.pointer, parameters.length)
	}
}

struct String {
    pointer: any
    length: integer
    static: boolean

	fn (pointer: any): String {
	    return String(pointer, length(pointer), false)
	}
	
	fn (pointer: any, length: integer): String {
	    return String(pointer, length, false)
	}

    fn hash(string: &String): integer {
        let total = 0
        let i = 0
        while i < string.length {
            total = total + @get_1(string.pointer + i)
            i = i + 1
        }
        return total
    }

	fn free_custom(string: &String) {
		if @not(string.static) {
			@free(string.pointer, string.length)
		}
	}
}

fn _==(string1: String, string2: String): boolean {
    if string1.length != string2.length {
        return false
    }

    let i = 0
    while i < string1.length {
        if @get_1(string1.pointer + i) != @get_1(string2.pointer + i) {
            return false
        }

        i = i + 1
    }

    return true
}

fn null(): any {
    return 0
}

struct LinkedList<A> {
    head: any

	fn <A>(): LinkedList<A> {
		return LinkedList<A>(LinkedList_Node<A>(null(), null()))
	}

	fn append<A>(linked_list: &LinkedList<A>, data: A) {
	    let node = @cast_&LinkedList_Node<A>(linked_list.head)
	    while node.next != null() {
	        node = @cast_&LinkedList_Node<A>(node.next)
	    }
	
	    let new_node = LinkedList_Node<A>(data, null())
	    node.next = new_node
	}

	fn insert<A>(linked_list: &LinkedList<A>, index: integer, data: A) {
	    let node = @cast_&LinkedList_Node<A>(linked_list.head)
	
	    let i = 0
	    while i < index {
	        node = @cast_&LinkedList_Node<A>(node.next)
	        i = i + 1
	    }
	
	    let temp_next = node.next
	    let new_node = LinkedList_Node<A>(data, @cast_any(temp_next))
	    node.next = new_node
	}

	fn remove<A>(linked_list: &LinkedList<A>, index: integer) {
	    let node = @cast_&LinkedList_Node<A>(linked_list.head)
	
	    let i = 0
	    while i < index {
	        node = @cast_&LinkedList_Node<A>(node.next)
		    i = i + 1
	    }
	
	    let temp_next_next = @cast_&LinkedList_Node<A>(node.next).next

        let node_to_free = @cast_LinkedList_Node<A>(@cast_any(node.next))

	    node.next = @cast_any(temp_next_next)
	}

	fn size<A>(linked_list: &LinkedList<A>): integer {
	    let node = @cast_&LinkedList_Node<A>(linked_list.head)
	    let i = 0
	
	    while node.next != null() {
	        node = @cast_&LinkedList_Node<A>(node.next)
	        i = i + 1
	    }
	
	    return i
	}

	fn free_custom<A>(list: &LinkedList<A>) {
		let node = list.head
		while node != 0 {
		    let new_node = @cast_&LinkedList_Node<A>(node).next

            let linked_node = @cast_LinkedList_Node<A>(@cast_any(node))

		    node = new_node
		}
	}
}

fn _[]<A>(linked_list: &LinkedList<A>, index: integer): &A {
    let node = @cast_&LinkedList_Node<A>(linked_list.head)
    let i = 0

    while i < (index + 1) {
        node = @cast_&LinkedList_Node<A>(node.next)
        i = i + 1
    }

    return @cast_&A(node.data)
}

struct LinkedList_Node<A> {
    data: any
    next: any

	fn free_custom<A>(node: &LinkedList_Node<A>) {
        let _ = @cast_A(@cast_any(node.data))
	}
}

struct HashMap<A, B> {
    size: integer
    array: Array<B>

    fn <A, B>(): HashMap<A, B> {
        return HashMap<A, B>(20)
    }

    fn <A, B>(size: integer): HashMap<A, B> {
        return HashMap<A, B>(size, Array<B>(size))
    }
}

fn _[]<A, B>(hash_map: &HashMap<A, B>, key: &A): &B {
    let position = key.hash()
    position = position % hash_map.size
    
    return hash_map.array[position]
}

fn _[]=<A, B>(hash_map: &HashMap<A, B>, key: A, value: B) {
    let position = key.hash()
    position = position % hash_map.size

    hash_map.array[position] = value
}

struct Option<A> {
    data: any

	fn empty<A>(): Option<A> {
	    return Option<A>(null())
	}
	
	fn of<A>(data: A): Option<A> {
	    return Option<A>(data)
	}
	
	fn is_value<A>(option: &Option<A>): boolean {
	    return not_equal(option.data, null())
	}
	
	fn free_custom<A>(option: &Option<A>) {
		if option.data != null() {
            let _ = @cast_A(@cast_any(option.data))
		}
	}

	fn data<A>(option: &Option<A>): &A {
		return @cast_&A(option.data)
	}
}

fn _+(value1: &any, value2: &any): any {
    return @add(value1, value2)
}

fn _+(value1: integer, value2: integer): integer {
    return @cast_integer(@add(value1, value2))
}

fn _-(value1: any, value2: any): any {
    return @subtract(value1, value2)
}

fn _-(value1: integer, value2: integer): integer {
    return @cast_integer(@subtract(value1, value2))
}

fn _%(value1: integer, value2: integer): integer {
    return @cast_integer(@modulo(value1, value2))
}

fn _/(value1: integer, value2: integer): integer {
    return @cast_integer(@divide(value1, value2))
}

fn _*(value1: integer, value2: integer): integer {
    return @cast_integer(@multiply(value1, value2))
}

fn _<(value1: integer, value2: integer): boolean {
    return @less(value1, value2)
}

fn _>(value1: integer, value2: integer): boolean {
    return @greater(value1, value2)
}

fn _==(value1: &any, value2: &any): boolean {
    return @equal(value1, value2)
}

fn _!=(value1: &any, value2: &any): boolean {
    return not_equal(value1, value2)
}

fn integer.memory_size(): integer {
	return 0
}

fn boolean.memory_size(): integer {
	return 0
}

fn any.memory_size(): integer {
	return 0
}
