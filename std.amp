fn print(string: String) {
    @print_size(string.pointer(), string.length());
};

fn println(string: String) {
    print(string);
    print("\n");
};

fn error(string: String) {
    @error_size(string, length(string));
};

fn errorln(string: String) {
    error(string);
    error("\n");
};

fn read(): String {
    let string = @allocate(128);
    @read_size(string, 128);
    return String.new(string);
};

fn execute_command(file: String, arguments: Array, wait: boolean) {
    @execute(to_null_terminated_string(file), to_null_terminated_array(arguments), wait);
    print("");
};

fn to_null_terminated_string(string: String): any {
    return (string + "\0").pointer();
};

fn to_null_terminated_array(array: Array): any {
    let new_array = Array.new(array.length());
    let i = 0;
    while (i < new_array.length()) {
        new_array.set(i, to_null_terminated_string(@cast_String(array.get(i))));
        i = i + 1;
    };
    return new_array.pointer();
};

fn length(string: any): integer {
    let location = string;
    let i = 0;

    while (true) {
        if (@get_1(location) == 0) {
            return i;
        };
        location = location + 1;
        i = i + 1;
    };

    return 999;
};

fn _+(string1: String, string2: String): String {
    let string1_length = string1.length();
    let string2_length = string2.length();
    let new_memory = @allocate(string1_length + string2_length);
    @copy(string1.pointer(), new_memory, string1_length);
    @copy(string2.pointer(), new_memory + string1_length, string2_length);
    return String.new(new_memory, string1_length + string2_length);
};

fn integer_to_string(integer: integer): String {
    let string = "";
    if (integer == 0) {
        string = "0";
    };
    
    while (integer > 0) {
        let modulo = integer % 10;
        integer = integer / 10;
        let string_old = string;
        let stored = store(modulo + 48);
        let prepended_string = String.new(stored, 1);
        string = prepended_string + string_old;
        @free(stored, 1);
        @free(prepended_string, 16);
        @free(string_old, 16);
    };
    return string;
};

fn boolean_to_string(boolean: boolean): String {
    if (boolean == 1) {
        return "true";
    };
    return "false";
};

fn store(value: integer): any {
    let new_memory = @allocate(1);
    @set_1(value, new_memory);
    return new_memory;
};

fn not_equal(value1: any, value2: any): boolean {
    return @not(@equal(value1, value2));  
};

struct Array {
    pointer: any;
    length: integer;
};

fn Array.new(size: integer): Array {
    return Array.new(@allocate((1 + size) * 8), size);
};

fn Array.set(array: Array, index: integer, value: any) {
    @set_8(@cast_integer(value), array.pointer() + (index * 8));
};

fn Array.get(array: Array, index: integer): any {
    return @get_8(array.pointer() + (index * 8));
};

struct Function {
    pointer: any;
};

fn Function.call(function: Function, parameters: Array): any {
    return @call_function(function.pointer(), parameters.pointer(), parameters.length());
};

struct String {
    pointer: any;
    length: integer;
};

fn String.new(pointer: any): String {
    return String.new(pointer, length(pointer));
};

fn _==(string1: String, string2: String): boolean {
    if (string1.length() != string2.length()) {
        return false;
    };

    let i = 0;
    while (i < string1.length()) {
        if (@get_1(string1.pointer() + i) != @get_1(string2.pointer() + i)) {
            return false;
        };

        i = i + 1;
    };

    return true;
};

fn null(): any {
    return 0;
};

struct LinkedList {
    head: LinkedList_Node;
};

fn LinkedList.new(): LinkedList {
    return LinkedList.new(LinkedList_Node.new(null(), @cast_LinkedList_Node(null())));
};

fn LinkedList.append(linked_list: LinkedList, data: any) {
    let node = linked_list.head();
    while (node.next() != null()) {
        node = node.next();
    };

    let new_node = LinkedList_Node.new(data, @cast_LinkedList_Node(null()));
    node.next(new_node);
};

fn LinkedList.insert(linked_list: LinkedList, index: integer, data: any) {
    let node = linked_list.head();

    let i: integer = 0;
    while (i < index) {
        node = node.next();
        i = i + 1;
    };

    let temp_next = node.next();
    let new_node = LinkedList_Node.new(data, temp_next);
    node.next(new_node);
};

fn LinkedList.remove(linked_list: LinkedList, index: integer) {
    let node = linked_list.head();

    let i: integer = 0;
    while (i < index) {
        node = node.next();
        i = i + 1;
    };

    let temp_next_next = node.next().next();
    node.next(temp_next_next);
};

fn LinkedList.get(linked_list: LinkedList, index: integer): any {
    let node = linked_list.head();
    let i: integer = 0;

    while (i < (index + 1)) {
        node = node.next();
        i = i + 1;
    };

    return node.data();
};

fn LinkedList.size(linked_list: LinkedList): integer {
    let node = linked_list.head();
    let i = 0;

    while (node.next() != null()) {
        node = node.next();
        i = i + 1;
    };

    return i;
};

fn LinkedList.to_array(linked_list: LinkedList): Array {
    let size = linked_list.size();
    let array = Array.new(size);
    let i = 0;
    let node = linked_list.head().next();

    while (i < size) {
        array.set(i, node.data());
        i = i + 1;
        node = node.next();
    };

    return array;
};

struct LinkedList_Node {
    data: any;
    next: LinkedList_Node;
};

struct Option {
    data: any;
};

fn Option.empty(): Option {
    return Option.new(null());
};

fn Option.of(data: any): Option {
    return Option.new(data);
};

fn Option.is_value(option: Option): boolean {
    return not_equal(option.data(), null());
};

fn _+(value1: any, value2: any): any {
    return @add(value1, value2);
};

fn _+(value1: integer, value2: integer): integer {
    return @cast_integer(@add(value1, value2));
};

fn _%(value1: integer, value2: integer): integer {
    return @cast_integer(@modulo(value1, value2));
};

fn _/(value1: integer, value2: integer): integer {
    return @cast_integer(@divide(value1, value2));
};

fn _*(value1: integer, value2: integer): integer {
    return @cast_integer(@multiply(value1, value2));
};

fn _<(value1: integer, value2: integer): boolean {
    return @less(value1, value2);
};

fn _>(value1: integer, value2: integer): boolean {
    return @greater(value1, value2);
};

fn _==(value1: any, value2: any): boolean {
    return @equal(value1, value2);
};

fn _!=(value1: any, value2: any): boolean {
    return not_equal(value1, value2);
};