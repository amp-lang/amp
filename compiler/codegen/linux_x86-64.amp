fn create_linux_x86_64_binary(name: &String, program: LinkedList<Box>) {
    let text_string = "format ELF64 executable\nentry start\nsegment readable executable\n"
    let data_string = "segment readable\n"
    let bss_string = "segment readable writable\n\tmemory: rb 8\n"

    let data_index = 0

    let i = 0
    while i < program.size() {
        let token = program[i]

        if token.type == FunctionToken {
            let function = @cast_&FunctionToken(token.value)
            if function.instructions.size() > 0 {
                text_string = text_string + function.name.remove_invalid() + "_"

                let j = 0
                while j < function.parameters.length {
                    let parameter = function.parameters[j]
                    text_string = text_string + parameter
                    if j < function.parameters.length - 1 {
                        text_string = text_string.replace("&", "") + "_"
                    }
                    j = j + 1
                }

                text_string = text_string + ":\n"
                text_string = text_string + "\tpush rbp\n"
                text_string = text_string + "\tmov rbp, rsp\n"
                text_string = text_string + "\tsub rsp, 1000\n"

                let map = HashMap<String, integer>(256, false)
                let current_declare = 0

                let j = 0
                while j < function.instructions.size() {
                    let instruction = function.instructions[j]

                    if instruction.type == StringToken {
                        let string = @cast_&StringToken(instruction.value)
                        data_string = data_string + "\t_" + string.value.remove_invalid() + "_" + data_index.to_string() + ": db "

                        let k = 0
                        while k < string.value.length {
                            let character = string.value[k]
                            let code = @cast_integer(@get_1(character.pointer))
                            data_string = data_string + code.to_string()
                            if k < string.value.length - 1 {
                                data_string = data_string + ","
                            }
                            k = k + 1
                        }

                        data_string = data_string + "\n"

                        text_string = text_string + "\tpush " + 1.to_string() + "\n"
                        text_string = text_string + "\tpush " + k.to_string() + "\n"
                        text_string = text_string + "\tpush _" + string.value.remove_invalid() + "_" + data_index.to_string() + "\n"
                        text_string = text_string + "\tcall String_any_integer_boolean\n"
                        text_string = text_string + "\tadd rsp, 24\n"
                        text_string = text_string + "\tpush r8\n"
                        data_index = data_index + 1
                    } else if instruction.type == IntegerToken {
                        let integer = @cast_&IntegerToken(instruction.value)
                        text_string = text_string + "\tpush " + integer.value.to_string() + "\n"
                    } else if instruction.type == BooleanToken {
                        let boolean = @cast_&BooleanToken(instruction.value)
                        let value = 0
                        if boolean.value {
                            value = 1
                        }
                        text_string = text_string + "\tpush " + value.to_string() + "\n"
                    } else if instruction.type == InvokeToken {
                        let invoke = @cast_&InvokeToken(instruction.value)
                        if @not(invoke.name.substring(0, 6) == "@cast_") {
                            text_string = text_string + "\tcall " + invoke.name.remove_invalid() + "_"
                            let k = 0
                            while k < invoke.parameters.length {
                                text_string = text_string + invoke.parameters[k].replace("&", "")
                                if (k + 1) < invoke.parameters.length {
                                    text_string = text_string + "_"
                                }
                                k = k + 1
                            }
                            text_string = text_string + "\n"
                            text_string = text_string + "\tadd rsp, " + (invoke.parameters.length * 8).to_string() + "\n"
                            text_string = text_string + "\tpush r8\n"
                        }
                    } else if instruction.type == ReturnToken {
                        let _return = @cast_&ReturnToken(instruction.value)
                        if _return.count > 0 {
                            text_string = text_string + "\tpop r8\n"
                        }
                        text_string = text_string + "\tmov rsp, rbp\n"
                        text_string = text_string + "\tpop rbp\n"
                        text_string = text_string + "\tret\n"
                    } else if instruction.type == DeclareToken {
                        let declare = @cast_&DeclareToken(instruction.value)
                        map[declare.name.clone()] = current_declare
                        current_declare = current_declare + 1
                    } else if instruction.type == StoreToken {
                        let store = @cast_&StoreToken(instruction.value)
                        let parameter_count = function.parameters.length
                        let local_index = map[store.name]
                        if local_index < parameter_count {
                            text_string = text_string + "\tpop qword [rbp+" + (16 + (local_index * 8)).to_string() + "]\n"
                        } else {
                            text_string = text_string + "\tpop qword [rbp-" + (8 + ((local_index - parameter_count) * 8)).to_string() + "]\n"
                        }
                    } else if instruction.type == RetrieveToken {
                        let retrieve = @cast_&RetrieveToken(instruction.value)
                        let parameter_count = function.parameters.length
                        let local_index = map[retrieve.name]
                        if local_index < parameter_count {
                            text_string = text_string + "\tpush qword [rbp+" + (16 + (local_index * 8)).to_string() + "]\n"
                        } else {
                            text_string = text_string + "\tpush qword [rbp-" + (8 + ((local_index - parameter_count) * 8)).to_string() + "]\n"
                        }
                    } else if instruction.type == JumpConditionalToken {
                        let jump_conditional = @cast_&JumpConditionalToken(instruction.value)
                        text_string = text_string + "\tpop r8\n"
                        text_string = text_string + "\tcmp r8, 1\n"
                        text_string = text_string + "\tje target_" + jump_conditional.id.to_string() + "\n"
                    } else if instruction.type == JumpToken {
                        let jump = @cast_&JumpToken(instruction.value)
                        text_string = text_string + "\tjmp target_" + jump.id.to_string() + "\n"
                    } else if instruction.type == TargetToken {
                        let target = @cast_&TargetToken(instruction.value)
                        text_string = text_string + "\ttarget_" + target.id.to_string() + ":\n"
                    }

                    j = j + 1
                }

                text_string = text_string + "\tmov rsp, rbp\n"
                text_string = text_string + "\tpop rbp\n"
                text_string = text_string + "\tret\n"
            }
        }

        i = i + 1
    }

    let internal_functions = get_internal_functions()

    let i = 0
    while i < internal_functions.size() {
        let internal_function = internal_functions[i]
        text_string = text_string + internal_function.name.remove_invalid() + ":\n"
        let j = 0
        while j < internal_function.instructions.size() {
            text_string = text_string + "\t" + internal_function.instructions[j] + "\n"
            j = j + 1
        }
        i = i + 1
    }

    let file = File::open("build/" + name + ".asm")
    file.write(text_string + data_string + bss_string)
    file.close()

    let arguments = Array<String>(2)
    arguments[0] = "/bin/fasm"
    arguments[1] = "build/" + name + ".asm"

    execute_command("/bin/fasm", arguments, true)

    let arguments = Array<String>(3)
    arguments[0] = "/bin/chmod"
    arguments[1] = "+x"
    arguments[2] = "build/" + name

    execute_command("/bin/chmod", arguments, true)
}

struct InternalFunction {
    name: String
    instructions: LinkedList<String>
}

fn get_internal_functions(): LinkedList<InternalFunction> {
    let functions = LinkedList<InternalFunction>()

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov rax, 12")
    instructions.append("mov rdi, 0")
    instructions.append("syscall") // rax now holds current brk
    instructions.append("mov rbx, rax")
    instructions.append("mov rdi, rbx")
    instructions.append("add rdi, 16384")
    instructions.append("mov rax, 12")
    instructions.append("syscall") // rax with brk, pointing to 16376 of free memory
    instructions.append("mov qword [memory], rbx")
    instructions.append("mov qword [rbx+8], 16384")
    instructions.append("call main_")
    instructions.append("mov rax, 60")
    instructions.append("xor rdi, rdi")
    instructions.append("syscall")
    functions.append(InternalFunction("start", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov rdx, [rbp+24]")
    instructions.append("mov rsi, [rbp+16]")
    instructions.append("mov rdi, 1")
    instructions.append("mov rax, 1")
    instructions.append("syscall")
    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@print_size_any_integer", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov rdx, [rbp+24]")
    instructions.append("mov rsi, [rbp+16]")
    instructions.append("mov [rsi], rdx")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@set_8_any_any", instructions))
    
    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov rsi, [rbp+16]")
    instructions.append("mov r8, [rsi]")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@get_8_any", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov rdx, [rbp+24]")
    instructions.append("mov rsi, [rbp+16]")
    instructions.append("add rsi, rdx")
    instructions.append("mov r8, rsi")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@add_any_any", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov r8, [rbp+16]")
    instructions.append("sub r8, [rbp+24]")
    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@subtract_any_any", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov r8, [rbp+16]")
    instructions.append("xor r8, 1")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@not_boolean", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov r8, [rbp+16]")
    instructions.append("cmp r8, [rbp+24]")
    instructions.append("jne equal_not_equal")
    instructions.append("equal_equal:")
    instructions.append("mov r8, 1")
    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    instructions.append("equal_not_equal:")
    instructions.append("mov r8, 0")
    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@equal_any_any", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov r8, [rbp+16]")
    instructions.append("cmp r8, [rbp+24]")
    instructions.append("jbe greater_not_greater")
    instructions.append("greater_greater:")
    instructions.append("mov r8, 1")
    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    instructions.append("greater_not_greater:")
    instructions.append("mov r8, 0")
    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@greater_integer_integer", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov r8, [rbp+16]")
    instructions.append("cmp r8, [rbp+24]")
    instructions.append("jae less_not_less")
    instructions.append("less_less:")
    instructions.append("mov r8, 1")
    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    instructions.append("less_not_less:")
    instructions.append("mov r8, 0")
    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@less_integer_integer", instructions))

    let instructions = LinkedList<String>()
    instructions.append("push rbp")
    instructions.append("mov rbp, rsp")
    instructions.append("mov rbx, [rbp+16]") // rbx = allocated size
    instructions.append("mov r12, rbx")

    instructions.append("xor rdx, rdx") // hacky solution bc buggyness happens when it's not a multiple of 8
    instructions.append("mov rax, rbx")
    instructions.append("mov r9, 8")
    instructions.append("div r9")
    
    instructions.append("cmp rdx, 0")
    instructions.append("je allocate_skip_filter")

    instructions.append("inc rax")
    instructions.append("mul r9")
    
    instructions.append("mov rbx, rax")
    instructions.append("allocate_skip_filter:")
    
    instructions.append("add rbx, 16") // add some padding which will be used for freeing later
    instructions.append("mov rcx, [memory]") // move the pointer to the first free value into rcx
    instructions.append("mov r9, memory")
    instructions.append("allocate_mark:") // used for jumping back if the memory block is not big enough
    
    instructions.append("cmp rcx, 0")
    instructions.append("jne no_alloc")
    instructions.append("push rax")
    instructions.append("push rbx")

    instructions.append("mov r11, 16384")
    instructions.append("cmp rbx, r11")
    instructions.append("jle no_special_case")
    instructions.append("mov r11, rbx")
    instructions.append("add r11, 16")

    instructions.append("no_special_case:")

    instructions.append("mov rax, 12")
    instructions.append("mov rdi, 0")
    instructions.append("push r11")
    instructions.append("syscall")
    instructions.append("pop r11")
    instructions.append("mov rbx, rax")

    instructions.append("mov rdi, rbx")
    instructions.append("add rdi, r11")
    instructions.append("mov rax, 12")
    instructions.append("push r11")
    instructions.append("syscall")
    instructions.append("pop r11")
    instructions.append("mov qword [r9], rbx")
    instructions.append("sub r11, 16")
    instructions.append("mov qword [rbx+8], r11")
    instructions.append("mov rcx, rbx")

    instructions.append("pop rbx")
    instructions.append("pop rax")

    instructions.append("no_alloc:")
    
    instructions.append("mov rax, rcx") // now rax stores beginning of new free memory

    instructions.append("mov r11, [rax+8]") // r11 stores the size of the free memory block
    instructions.append("mov r12, rbx")
    instructions.append("add r12, 16")

    instructions.append("cmp r12, r11")

    instructions.append("jle allocate_done")
    instructions.append("mov r9, rcx") // r9 stores the previous location used
    instructions.append("mov rcx, [rax]")

    instructions.append("jmp allocate_mark")
    instructions.append("allocate_done:")
    instructions.append("mov r10, rcx") // rcx = location
    instructions.append("add r10, rbx") // rbx = size, r10 = location + size
    instructions.append("sub r11, rbx") // r11 now with new length
    instructions.append("cmp r11, 16")
    instructions.append("jge not_zero")

    instructions.append("mov rdi, [rax]")
    instructions.append("mov [r9], rdi") // store next in previous location's next

    instructions.append("jmp done")
    instructions.append("not_zero:")

    instructions.append("mov [r9], r10") // store location + size in the previous location's next
    instructions.append("mov r9, [rax]")
    instructions.append("mov qword [r10], r9") // store at location + size = the next location
    instructions.append("mov [r10+8], r11") // store length in location + size + 8

    instructions.append("done:")
    
    instructions.append("mov r8, rcx") // move the index of the memory into r8
    instructions.append("sub rbx, 16")
    instructions.append("mov rcx, 0")
    instructions.append("allocate_zero:")
    instructions.append("cmp rcx, rbx")
    instructions.append("je allocate_zero_done")
    instructions.append("mov r9, r8")
    instructions.append("add r9, rcx")
    instructions.append("mov qword [r9], 0")
    instructions.append("add rcx, 8")
    instructions.append("jmp allocate_zero")
    instructions.append("allocate_zero_done:")

    instructions.append("mov rsp, rbp")
    instructions.append("pop rbp")
    instructions.append("ret")
    functions.append(InternalFunction("@allocate_integer", instructions))

    return functions
}

access String {
    fn remove_invalid(string: &String): String {
        let new_string = string.clone()
        let invalid = "! \\\n+"
        let i = 0
        while i < invalid.length {
            let replaced = invalid[i]
            new_string = new_string.replace(invalid[i], @cast_integer(@get_1(replaced.pointer)).to_string())
            i = i + 1
        }

        return new_string
    }
}
